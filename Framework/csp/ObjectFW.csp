--Object
--Models java.lang.Object



datatype WaitType = wait | waitForObject


	channel waitCall : ObjectID . ThreadID
	channel timedWaitCall : ObjectID . ThreadID . JTime 
	channel waitRet : ObjectID . ThreadID
	channel waitForObjectCall : ObjectID . ThreadID . JTime 
	channel waitForObjectRet : ObjectID . ThreadID . Bool 
	channel notify : ObjectID . ThreadID
	channel notifyAll : ObjectID . ThreadID	

	channel unlock_Monitor : ObjectID . ThreadID
	channel relock: ObjectID . ThreadID
	channel relock_this : ObjectID . ThreadID 
	channel startSynchMeth : ObjectID . ThreadID 
	channel lockAcquired : ObjectID . ThreadID 
	channel endSyncMeth : ObjectID . ThreadID
	channel cancel_wait_timer : ObjectID . ThreadID 
	channel start_timer : ObjectID . ThreadID . PriorityLevel . JTime
	channel lock_request : ObjectID . ThreadID 
	channel assignLock : ObjectID  
	channel add_to_wait : ObjectID . ThreadID . PriorityLevel . WaitType 
	channel remove_from_wait : ObjectID . ThreadID . PriorityLevel 
	channel remove_most_eligible_from_wait : ObjectID 
	channel removed_thread : ObjectID . ThreadID . WaitType 
	channel get_lockedBy : ObjectID . ThreadID 
	channel get_waitQueue : ObjectID . PriorityQueue 
	channel reset_lockedBy : ObjectID 
	channel fully_unlock : ObjectID 
	channel increment_locks : ObjectID 
	channel decrement_locks : ObjectID . Int
	channel get_ceilingPriority : ObjectID . PriorityLevel  
	channel start_waitForObject_timer : ObjectID . ThreadID  . PriorityLevel . JTime 
	channel get_waitForObjectThreads : ObjectID . Set(ThreadID)




ObjectFW(object) =
	( 
		ObjectState(PriorityQueue, nullSchedulableID, 0, {}, PriorityQueue,MaxPriority, {}) 
		[| ObjectStateSync |]
		Execute
	)\(done_toplevel_sequencer -> SKIP)


{\circstateignore  State}
	waitQueue: PriorityQueue  
	lockedBy : ThreadID 
	locks : \nat 
	previousLocks : ThreadMap 
	queueForLock : PriorityQueue 	
	ceilingPriority : PriorityLevel 
	waitForObjectThreads : \power ThreadID 
\where
	locks > 0 \iff lockedBy != nullSchedulableID 
	lockedBy \notin \dom previousLocks 
	lockedBy \notin ElementsOf( waitQueue) 
	lockedBy \notin ElementsOf( queueForLock )  
	waitForObjectThreads \subseteq ElementsOf( waitQueue ) 


ObjectState(waitQueue, lockedBy, locks, previousLocks, queueForLock,ceilingPriority, waitForObjectThreads) =


 --WaitQueueController =  
 (
	add_to_wait.object?someThread?priorityLevel?waitType -> 
	 AddToWaitQueue  ; 
	WaitQueueController 
 ) 
 []
 (                                                                                                                                   
 	remove_from_wait.object?waitingThread?priorityLevel ->  
 	 RemoveThreadFromWaitQueue   ;  	
	WaitQueueController 		
 ) 
 []
 (
 	\lcircguard IsEmpty(waitQueue) = False \rcircguard \circguard 
 	\circvar notified : ThreadID \circspot 
 	\circvar waitType : WaitType \circspot 
	 RemoveMostEligigbleFromWaitQueue   ; 
	removed_thread.object!notified!waitType -> 
 	WaitQueueController 
 ) 
 []
 (
 	get_waitQueue.object!waitQueue -> 
 	WaitQueueController 	
 ) 
 []
 (
 	get_waitForObjectThreads.object!waitForObjectThreads -> 
 	WaitQueueController 	
 )  

{Init}
	State' 	
\where
	IsEmpty(queueForLock') = True
	IsEmpty(waitQueue') = True 
	locks' = 0	
	previousLocks' = \emptyset 	
	ceilingPriority' = MaxPriority 
	waitForObjectThreads' = \emptyset  
	

{FullyUnlock}
\Delta State
lockedBy? : ThreadID 
locks? : \nat_1
\where
previousLocks' = previousLocks \oplus {lockedBy? \mapsto locks?} 
lockedBy' = nullSchedulableID 
locks' = 0 
waitQueue' = waitQueue 
queueForLock' = queueForLock 
ceilingPriority'= ceilingPriority 
waitForObjectThreads' = waitForObjectThreads 


{AddToQueueForLock}
\Delta State 
someThread? : ThreadID 
priorityLevel? : PriorityLevel 

\where
someThread? != nullSchedulableID 
someThread? \notin ElementsOf (queueForLock ) 
queueForLock' = AddToPriorityQueue(queueForLock, someThread?, priorityLevel?) 
lockedBy' = lockedBy 
locks' = locks
previousLocks' = previousLocks 
waitQueue' = waitQueue 
ceilingPriority'= ceilingPriority 
waitForObjectThreads' = waitForObjectThreads 


{AssignEligible}
\Delta State 
\where
(queueForLock', lockedBy') = RemoveFromPriorityQueue(queueForLock) 
lockedBy' \in \dom previousLocks \implies locks' = previousLocks(lockedBy') 
lockedBy' \notin \dom previousLocks \implies locks' = 1 
previousLocks' = {lockedBy} \ndres previousLocks  
waitQueue' = waitQueue 
ceilingPriority'= ceilingPriority 
waitForObjectThreads' = waitForObjectThreads 


{AddToWaitQueue}
\Delta State 
someThread? : ThreadID 
priorityLevel? : PriorityLevel 
waitType? : WaitType 
\where
someThread? != nullSchedulableID 
someThread? \notin ElementsOf(waitQueue) 
waitQueue' = AddToPriorityQueue(waitQueue, someThread?, priorityLevel?)  	
lockedBy' = lockedBy 
locks' = locks
previousLocks' = previousLocks 
queueForLock' = queueForLock
ceilingPriority'= ceilingPriority 
waitType? = waitForObject \implies waitForObjectThreads' = waitForObjectThreads \cup {someThread? } 
waitType? = wait \implies waitForObjectThreads' = waitForObjectThreads 


{RemoveThreadFromWaitQueue}
\Delta State 
waitingThread? : ThreadID 
priorityLevel? : PriorityLevel 
\where
waitingThread? \in \ran(waitQueue(priorityLevel?)) 
waitQueue' = RemoveThreadFromPriorityQueue(waitQueue, waitingThread?, priorityLevel?) 
lockedBy' = lockedBy 
locks' = locks
previousLocks' = previousLocks 
ceilingPriority'= ceilingPriority 
waitForObjectThreads' = waitForObjectThreads \setminus { waitingThread? } 


{RemoveMostEligigbleFromWaitQueue}
\Delta State 
notified! : ThreadID 
waitType! : WaitType 
\where
(waitQueue', notified!)  = RemoveFromPriorityQueue(waitQueue)    
lockedBy' = lockedBy 
locks' = locks 
previousLocks' = previousLocks 
queueForLock' = queueForLock 
ceilingPriority'= ceilingPriority 
notified! \in waitForObjectThreads \implies waitType! = waitForObject 
notified! \notin waitForObjectThreads \implies waitType! = wait 
waitForObjectThreads' = waitForObjectThreads \setminus {notified!}







Execute(thread, interruptedThreads) = 
(
	(
		( Monitor
		[|  MonitorSync |]
	Synchronisation 
	) 
	[|   MLCSync |]
	MonitorLockController(interruptedThreads)
) 
 \lpar { waitQueue, waitForObjectThreads, queueForLock, previousLocks, locks, lockedBy } |   CPCSync |   { ceilingPriority } \rpar 
 CeilingPriorityController 
)  




Monitor = 
	MonitorUnlocked



MonitorUnlocked = 
 (
	startSynchMeth.object?someThread -> 	
	lock_request.object!someThread ->
	MonitorUnlocked		
) 
 [] 
 (
	lockAcquired.object?lockingThread -> 
	get_ceilingPriority.object?ceilingPriority -> 
	(
		(
			get_priorityLevel.lockingThread.object?priority:(priority <= ceilingPriority) -> 
			raise_thread_priority.lockingThread!ceilingPriority ->  
			MonitorLocked(lockingThread) 
		)
		[]
		(
			get_priorityLevel.lockingThread.object?priority:(priority > ceilingPriority) -> 
			throw.ceilingViolationException -> 
			CHAOS(Events)
		)
		
	)	
) 



MonitorLocked(lockedBy)=

	(
		startSynchMeth.object.lockedBy -> 	
		increment_locks.object -> 
		MonitorLocked(lockedBy)

	)	
	[] 
	(
		startSynchMeth.object?someThread:(diff(ThreadID,lockedBy)) -> 	
		lock_request.object!someThread ->
		MonitorLocked(lockedBy)

	)	
	[] 
	(
		endSyncMeth.object.lockedBy -> 
		(
			(
				decrement_locks.object.0 -> 
				lower_thread_priority.lockedBy -> 	
				MonitorUnlocked
			) 
			[] 
			(
				decrement_locks.object?l:(diff(Int, 0)) -> 
				MonitorLocked(lockedBy)

			) 
		
		) 		
	)	
	[] 
	(
		unlock_Monitor.object?unlockingThread -> 
		fully_unlock.object ->  
		lower_thread_priority.unlockingThread -> 
		MonitorUnlocked
	) 



Synchronisation = 
 (
	(
		(
			WaitActions 
			[| WaitSync |]
			NotifyActions 
		) 
	[|   WQSync |]
	WaitQueueController  
	) 
	[| InterruptSync |]
	Interrupt
	)



WaitActions = 
	(Wait ||| TimedWait) ||| WaitForObject 



NotifyActions = 
	Notify ||| NotifyAll





Wait = 

waitCall.object?someThread ->  
 ( 
	(
		isInterruptedCall.someThread -> 
		isInterruptedRet.someThread.False ->
		(
		(
			get_lockedBy.object.someThread -> 
			get_priorityLevel.someThread.object?priorityLevel -> 
			add_to_wait.object!someThread!priorityLevel!wait -> 
			unlock_Monitor.object!someThread ->  
			Wait
		) 	
		[]  
		(
			get_lockedBy.object?lockedBy:( diff(ThreadID, someThread) ) -> 
			throw.illegalMonitorStateException -> 
			CHAOS(Events)
		) 
	) 
	) 
	[] 
       (
       		isInterruptedCall.someThread -> 
       		isInterruptedRet.someThread.True -> 
       		throw.interruptedException -> 
       		CHAOS(Events)
       )
)
	

		

TimedWait = 
	TimedWaitHandler
	[| {| start_timer |} |]
	(||| t : ThreadID @ TimedWaitTimer(t))




TimedWaitHandler = 

    timedWaitCall.object?someThread?waitTime -> 	
    (
	(
	get_lockedBy.object.someThread -> 
		if ( (timeMillis(waitTime) < 0) or (timeNanos(waitTime) < 0 and timeNanos(waitTime) > maxNanos) ) then 
		(
			throw.illegalArgumentException ->  
			CHAOS(Events)
		) 
		else 
		(
			get_priorityLevel.someThread.object?priorityLevel -> 
			add_to_wait.object!someThread!priorityLevel!wait -> 
			start_timer.object!someThread!priorityLevel!waitTime -> 
			unlock_Monitor.object!someThread -> 
			TimedWaitHandler
		) 
		
	)			
 [] 
	(	
		get_lockedBy.object?lockedBy:(diff(ThreadID, someThread) ) -> 
		throw.illegalMonitorStateException -> 
		CHAOS(Events)
	)
    )	



TimedWaitTimer(waitingThread) = 
(
	start_timer.object.waitingThread?priorityLevel?waitTime -> 
	(
	(
		(
			circwait.waitTime ->
			remove_from_wait.object!waitingThread!priorityLevel ->  			
			waitRet.object!waitingThread ->
			SKIP 
		) 
		[]  
		(
			cancel_wait_timer.object.waitingThread -> 
			SKIP
		)
         	
	)
	; 
	relock_this.object!waitingThread -> 
	TimedWaitTimer(waitingThread)
	)
	) 
	[] 
	(
		cancel_wait_timer.object.waitingThread -> 
		TimedWaitTimer(waitingThread)
	)
 [] 
 (
	(waitRet.object.waitingThread -> TimedWaitTimer(waitingThread))
	[] 
	(waitForObjectRet.object.waitingThread?w -> TimedWaitTimer(waitingThread))
     
)

	


WaitForObject = 
	WaitForObjectHandler
	[| {| start_waitForObject_timer |} |]
	(||| t : ThreadID @ WaitForObjectTimer(t))



WaitForObjectHandler = 
    waitForObjectCall.object?someThread?waitTime -> 	
    (
	(
	get_lockedBy.object.someThread -> 
		if ( (timeMillis(waitTime) < 0) or (timeNanos(waitTime) < 0) ) then 
		(
			throw.illegalArgumentException ->  
			CHAOS(Events)
		 ) 
		else ( (timeMillis(waitTime) >= 0) and (timeNanos(waitTime) >= 0) ) then 
		(
			get_priorityLevel.someThread.object?priorityLevel -> 
			add_to_wait.object?someThread?priorityLevel!waitForObject -> 
			start_waitForObject_timer.object!someThread!priorityLevel!waitTime -> 
			unlock_Monitor.object!someThread -> 
			WaitForObjectHandler
		 ) 
		
	 )			
 [] 
	(	
		get_lockedBy.object?lockedBy:(diff(ThreadID, someThread) ) -> 
		throw.illegalMonitorStateException -> 
		CHAOS(Events)
	 )
     )	



WaitForObjectTimer(waitingThread) = 
(
	start_waitForObject_timer.object?waitingThread?priorityLevel?waitTime -> 
	(
	(
		(
			circwait.waitTime -> 
			remove_from_wait.object!waitingThread!priorityLevel ->  			
			waitForObjectRet.object!waitingThread!False ->
			SKIP 
		 ) 
		[]  
		(
			cancel_wait_timer.object.waitingThread -> 
			SKIP
		 )
         	
	 ) ; 
	relock_this.object!waitingThread -> 
	WaitForObjectTimer(waitingThread)
	 )
	 ) 
	[] 
	(
		cancel_wait_timer.object.waitingThread -> 
		WaitForObjectTimer(waitingThread)
	 ) 
 [] 
 (
	(waitRet.object?n -> WaitForObjectTimer(waitingThread))
	[] 
	(waitForObjectRet.object?n?w -> WaitForObjectTimer(waitingThread))
     
)

	


Notify = 
(
 notify.object?someThread -> 
 (
	(
		get_lockedBy.object.someThread -> 
		(
			if  IsEmpty(waitQueue) = False  then 
			(
				ResumeThread ;
			 	Notify
			) 
			else  IsEmpty(waitQueue) = True then 
				Notify
			
		)
	)
 [] 
	(
		get_lockedBy.object?lockedBy:(diff(ThreadID, someThread)) -> 
		throw.illegalMonitorStateException -> 
		CHAOS(Events)
	) 
) 
) 
 [] 
 (
	(waitRet.object?n -> Notify)
	[] 
	(waitForObjectRet.object?n?w -> Notify)
     
     )



ResumeThread = 
 		(
					removed_thread.object?notified.wait -> 
					cancel_wait_timer.object!notified -> 
					relock_this.object!notified -> 
					waitRet.object!notified -> 
					SKIP
				)
				[]
				(
					removed_thread.object?notified.waitForObject -> 
					cancel_wait_timer.object!notified -> 
					relock_this.object!notified -> 
					waitForObjectRet.object!notified!True -> 
					SKIP
				)		



NotifyAll = 
 (
 	notifyAll.object?someThread -> 
 	(
		(			
			get_lockedBy.object.someThread -> 
			NotifyAllHandler ;
			NotifyAll
		)  	
		[] 
		(
			get_lockedBy.object?lockedBy:(diff(ThreadID, someThread)) -> 
			throw.illegalMonitorStateException -> 
			CHAOS(Events)
		) 
	)
  )
 [] 
 (
	(waitRet.object?n -> NotifyAll)
	[] 
	(waitForObjectRet.object?n?w -> NotifyAll)
     
    )



NotifyAllHandler(notified) =
	if  IsEmpty(waitQueue) = False then 
	(
		ResumeThread ;		
		NotifyAllHandler
	 )  
	else  IsEmpty(waitQueue) = True then 
		SKIP  

	









 



Interrupt = 

	interrupt?waitingThread -> 
(

(
	get_waitQueue.object?retreivedWait:(waitingThread \in ElementsOf(retreivedWait)  ) -> 
 	cancel_wait_timer.object!waitingThread -> 
 	get_priorityLevel.waitingThread.object?priorityLevel -> 
 	remove_from_wait.object!waitingThread!priorityLevel -> 
	relock_this.object!waitingThread -> 
  	(
		(
			get_waitForObjectThreads.object?wfot:(waitingThread \notin wfot) -> 					
			waitRet.object!waitingThread -> 
			SKIP
		)
		[]
		(
			get_waitForObjectThreads.object?wfot:( wfot ) -> 
			waitForObjectRet.object!waitingThread!True -> 
			SKIP
		)		 	
 	)	; 	
 	
	Interrupt
 ) 
 [] 
 (
 	get_waitQueue.object?retreivedWait:(waitingThread \notin ElementsOf( retreivedWait ) ) -> 
	Interrupt 
   )
 ) 




MonitorLockController(interruptedThreads) = 
 (
	lock_request.object?someThread ->
	get_priorityLevel.someThread.object?priorityLevel -> 
	 AddToQueueForLock  ; 	
	MonitorLockController(interruptedThreads)  
)    
 []
 (
	relock_this.object?someThread -> 
	get_priorityLevel.someThread.object?priorityLevel -> 
	(
		 AddToQueueForLock  ; 	
		(
			(	
				isInterruptedCall.someThread -> 
				isInterruptedRet.someThread.False ->
				MonitorLockController(interruptedThreads) 
			)
			[] 
			(
				isInterruptedCall.someThread -> 
				isInterruptedRet.someThread.True ->
				--interruptedThreads := interruptedThreads \cup {someThread} ; 
				MonitorLockController(union(interruptedThreads, {someThread}) ) 
			)
		)
	)
)
 []
 (	
		IsEmpty(queueForLock) = False and lockedBy = nullSchedulableID &
		(	
			 AssignEligible   ; 
			lockAcquired.object.lockedBy -> 
			if member(lockedBy,interruptedThreads) then 
			(				
				throw.interruptedException -> 
				Chaos(Events)
			) 
			[] 
			else 
				MonitorLockController(interruptedThreads)										
			
		)	
	)
 []
 (	
	get_lockedBy.object!lockedBy -> 
	MonitorLockController(interruptedThreads)
	)	
 []
 (	
	increment_locks.object -> 
	locks := locks +1 ; 
	MonitorLockController(interruptedThreads) 
)
 []
 (		
	decrement_locks.object!(locks - 1)  -> 
	(
		locks := locks -1 ; 
		(
			if locks = 0 then 
			(
				lockedBy := nullSchedulableID ; 
				MonitorLockController(interruptedThreads) 
			)
			else locks != 0 then 
				 MonitorLockController(interruptedThreads)  			
		)
	) 
)
 []
 (		
	fully_unlock.object -> 
	 FullyUnlock  ; 
	MonitorLockController(interruptedThreads) 
)



CeilingPriorityController(ceilingPriority) = 
(
 	setCeilingPriority?mission!object?priority -> 
 	GetCeilingPriority(priority)
) 
 [] 
( 
	get_ceilingPriority.object!ceilingPriority -> 
	CeilingPriorityController(ceilingPriority)
)


GetCeilingPriority(ceilingPriority) =
	get_ceilingPriority.object!ceilingPriority -> 
	GetCeilingPriority(ceilingPriority)




  
