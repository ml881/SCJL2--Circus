\begin{zsection}
  \SECTION ~ PeriodicEventHandlerFW ~ \parents ~ MissionChan, SchedulableChan, SchedulableId,\\
   \quad MissionId, MissionIds, TopLevelMissionSequencerChan, PeriodicEventHandlerChan, \\
   \quad SafeletMethChan, FrameworkChan, PeriodicParameters
\end{zsection}
%
\begin{circus}
  \circprocess PeriodicEventHandlerFW ~ \circdef \\
  \quad ~ schedulable : SchedulableID ; periodicParameters : PeriodicParameters \circspot ~\circbegin
\end{circus}
%
\begin{schema}{\circstateignore State}
  controllingMission : MissionID\\
  applicationTerminating : \boolean \\
  period : JTime \\
  startTime : JTime \\
  deadline : JTime \\
  deadlineMissHandler : SchedulableID\\
  missedReleases : \nat \\
  periodicTerminating : \boolean \\
\where
	valueOf(deadline) \leq valueOf(period)
\end{schema}
%
\begin{parser}
\begin{circusaction}
\circstate State
\end{circusaction}
\end{parser}
%
\begin{schema}{Init}
  State~'\\
\where
  controllingMission' = nullMissionId\\
  applicationTerminating' = \false \\
  periodicTerminating' = \false \\
  period' = periodOf(periodicParameters)\\
  startTimeOf(periodicParameters) = NULL \implies startTime' = time~(0,0)\\
  startTimeOf(periodicParameters) \neq NULL \implies \\ \quad startTime' = startTimeOf(periodicParameters)\\
  deadlineOfPeriodic(periodicParameters) = NULL \implies \\ \quad deadline' = period'\\
  deadlineOfPeriodic(periodicParameters) \neq NULL \implies \\ \quad deadline' =  deadlineOfPeriodic(periodicParameters) \\
  missedReleases' = 0 \\
  deadlineMissHandler' = missHandlerOfPeriodic(periodicParameters) \\
\end{schema}
%
\begin{circusaction}
Start \circdef\\
\quad \circblockopen
   Register \circseq \\
   Activate
 \circblockclose  \\
\quad  \extchoice\\
\quad \circblockopen
  		activate\_schedulables?someMissionID \then \\
  		Start
   \circblockclose  \\
\quad \extchoice \\
\quad \circblockopen
		done\_toplevel\_sequencer \then \\
		applicationTerminating := \true \\
	 \circblockclose
\end{circusaction}
%
\begin{circusaction}
Register \circdef \\
\quad    register~.~schedulable~?~missionID \then \\
\quad    controllingMission := missionID
\end{circusaction}
%
\begin{circusaction}
Activate ~ \circdef ~ \\
\quad    activate\_schedulables~.~controllingMission \then \\
\quad    \Skip
\end{circusaction}

\begin{circusaction}
Execute \circdef  \\
\quad\circblockopen
  	\circblockopen
		\circblockopen
			\circwait valueOf(startTime) \circseq \\
			\circif deadlineMissHandler \neq nullSchedulableId \circthen \\
  			\quad	RunningWithDeadlineDetection \\
  			\circelse deadlineMissHandler = nullSchedulableId \circthen \\
  			\quad	Running \\
	  		\circfi
	  	 \circblockclose \\
  		\extchoice\\
  		\circblockopen
		 	end\_releases~.~schedulable \then \\
			\Skip\\
		 \circblockclose
	\circblockclose   \\
\quad  \lpar \{startTime\} |\lchanset stop\_period \rchanset| \emptyset \rpar\\
	SignalTermination
  \circblockclose \\
  \quad  \lpar \{startTime\} | PTCSYnc | \emptyset \rpar\\
  PeriodicTerminatingController
\end{circusaction}
%
\begin{circusaction}
Running \circdef \\
\quad\circblockopen
		PeriodicClock \\
		\quad \lpar \emptyset | ReleaseSync | \{ missedReleases \}  \rpar \\
		Release(0)
   \circblockclose
\end{circusaction}
%
\begin{circusaction}
RunningWithDeadlineDetection \circdef \\
\quad\circblockopen
		Running \\
		\quad \lpar \{missedReleases\} | ReleaseSync  | \emptyset  \rpar \\
		DeadlineClock(0) \\
   \circblockclose
\end{circusaction}
%
\begin{circusaction}
PeriodicClock \circdef \\
\quad release~.~schedulable \then \\
\quad   \circblockopen
\circmu X \circspot
  \circblockopen
	\circblockopen
		\circwait valueOf(period) \circseq \\
		release~.~schedulable \then \\
		X
	\circblockclose \\
	\extchoice \\
	\circblockopen
		end\_releases~.~schedulable \then \\
		\Skip \\
	 \circblockclose
  \circblockclose
  \circblockclose
\end{circusaction}
%
\begin{circusaction}
Release \circdef \circval index : \nat \circspot \\
 \circif missedReleases = 0 \circthen \\
\quad \circblockopen
	release~.~schedulable \then \\
	handleAsyncEventCall~.~schedulable \then \\
	\Skip
  \circblockclose \\
 \circelse missedReleases \neq 0 \circthen \\
\quad \circblockopen
	handleAsyncEventCall~.~schedulable \then \\
	missedReleases := missedReleases -1 \circseq \\
	\Skip
     \circblockclose \\
 \circfi \circseq \\
 \circblockopen
	\circblockopen
		handleAsyncEventRet~.~schedulable \then \\
		periodic\_release\_complete~.~schedulable~.~index \then \\
		\Skip
	\circblockclose  \\
\quad	\lpar \emptyset | \lchanset handleAsyncEventRet \rchanset | \emptyset \rpar \\
   \circblockopen
   \circmu X \circspot
	\circblockopen
		\circblockopen
			release~.~schedulable \then \\
			missedReleases := missedReleases +1 \circseq \\
			X
		\circblockclose  \\
		\extchoice \\
		\circblockopen
			handleAsyncEventRet~.~schedulable \then \\
			\Skip
		\circblockclose
	\circblockclose
   \circblockclose
\circblockclose 	\circseq \\
\circblockopen
	\circblockopen
		get\_periodicTerminating~.~schedulable~?~periodicTerminating\prefixcolon(periodicTerminating = \false) \then \\
		Release(index + 1)
	\circblockclose \\
	\extchoice \\
	\circblockopen
		get\_periodicTerminating~.~schedulable~?~periodicTerminating\prefixcolon(periodicTerminating = \true) \then \\
		\Skip
	\circblockclose
\circblockclose
\end{circusaction}
%
\begin{circusaction}
DeadlineClock \circdef \circval index : \nat \circspot \\
\quad \circblockopen
		\circblockopen
			\circblockopen
				\circwait valueOf(deadline) \circseq \\
				release~.~deadlineMissHandler \then \\
				periodic\_release\_complete~.~schedulable~.~index \then \\
				\Skip
			\circblockclose  \\
			\extchoice \\
			\circblockopen
		 		periodic\_release\_complete~.~schedulable~.~index \then \\
				\Skip
			\circblockclose
		\circblockclose
		\interleave
		\circblockopen
			\circblockopen
				\circwait valueOf(period) \circseq \\
				DeadlineClock(index + 1)
			\circblockclose  \\
		\circblockclose


    \circblockclose  \\
\quad  \circinterrupt
    \circblockopen
    		end\_releases~.~schedulable \then \\
    		periodic\_release\_complete~.~schedulable~?~index \then \\
    		\Skip
    \circblockclose
\end{circusaction}
%
\begin{circusaction}
SignalTermination \circdef \\
\quad	signalTerminationCall~.~schedulable\then\\
\quad 	set\_periodicTerminating~.~schedulable~!~\true \then \\
\quad	end\_releases~.~schedulable \then\\
\quad	signalTerminationRet~.~schedulable \then\\
\quad	done\_schedulable~.~schedulable \then\\
\quad	\Skip\\
\end{circusaction}
%
\begin{circusaction}
Cleanup \circdef \\
\quad cleanupSchedulableCall~.~schedulable \then\\
\quad cleanupSchedulableRet~.~schedulable \then \\
\quad \Skip
\end{circusaction}
%
\begin{circusaction}
PeriodicTerminatingController \circdef \\
\quad \circblockopen
	get\_periodicTerminating~.~schedulable~!~periodicTerminating \then \\
	PeriodicTerminatingController
    \circblockclose \\
\quad \extchoice \\
\quad \circblockopen
	set\_periodicTerminating~.~schedulable~?~newPeriodicTerminating \then \\
	periodicTerminating := newPeriodicTerminating \circseq \\
	PeriodicTerminatingController
    \circblockclose
\end{circusaction}
%
\begin{circusaction}
\circspot\circblockopen \circmu X \circspot\circblockopen  \lschexpract Init \rschexpract  \circseq Start \circseq\\
\circblockopen \circif applicationTerminating = \false \circthen \\
	\qquad \circblockopen Execute \circseq Cleanup \circseq X\circblockclose \\
 \circelse applicationTerminating = \true \circthen \\
 	\qquad\circblockopen
 		end\_periodic\_app~.~schedulable \then \\
 		\Skip
 	\circblockclose \\
\circfi \circblockclose  \circblockclose  \circblockclose
\end{circusaction}
%
\begin{circus}
  \circend
\end{circus}
