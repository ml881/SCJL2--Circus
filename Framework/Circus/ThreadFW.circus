\begin{zsection}
  \SECTION ~ ThreadFW ~ \parents ~ scj\_prelude, GlobalTypes,\\
  \quad  ThreadChan, ObjectFWChan, FrameworkChan, Priority
\end{zsection}
%
\begin{circus}
  \circprocess ThreadFW  ~ \circdef ~ thread : ThreadID ; basePriority : PriorityLevel ~ \circspot ~\circbegin
\end{circus}
%
\begin{schema}{\circstateignore ~ State}
	priorityStack : \seq_1 PriorityLevel \\
	activePriority : PriorityLevel \\
	interrupted : \boolean
\where
	activePriority = last~priorityStack
\end{schema}
%
\begin{parser}
\begin{circusaction}
\circstate State
\end{circusaction}
\end{parser}
%
\begin{schema}{Init}
	\Delta State  \\
\where
	priorityStack' = \langle basePriority \rangle \\
	interrupted' = \false
\end{schema}
%
\begin{circusaction}
Execute \circdef \\
\quad 	 \circblockopen
		 \circblockopen
			 \circblockopen
				Priority \\
				\linter \{ basePriority \} | \{ interrupted \} \rinter\\
				Interrupts
			 \circblockclose \\
			\interleave \\
			GetPriorityLevel \\
		 \circblockclose
	 \circblockclose \\
\circinterrupt
		 \circblockopen
			done\_toplevel\_sequencer \then \\
			\Skip
		 \circblockclose
\end{circusaction}
%
\begin{circusaction}
Priority \circdef \\
\quad \circif priorityStack = \langle basePriority \rangle \circthen \\
\qquad	IncreasePriority \\
\quad \circelse priorityStack \neq \langle basePriority \rangle \circthen \\
\qquad	 \circblockopen
		IncreasePriority \\
		\extchoice
		DecreasePriority
	 \circblockclose\\
\quad \circfi
\end{circusaction}
%
\begin{circusaction}
IncreasePriority \circdef \\
\quad	raise\_thread\_priority~.~thread~?~ceilingPriority \then \\
\quad	activePriority := ceilingPriority \circseq \\
\quad	IncreasePriority
\end{circusaction}
%
\begin{circusaction}
DecreasePriority \circdef \\
\quad	lower\_thread\_priority~.~thread \then \\
\quad	activePriority := basePriority \circseq \\
\quad 	DecreasePriority
\end{circusaction}
%
\begin{circusaction}
Interrupts \circdef \\
\quad  \circblockopen
	 \circblockopen
		 \circblockopen
			Interrupt \\
			\quad \linter \emptyset | \emptyset \rinter \\
			IsInterrupted
		 \circblockclose \\
		\quad \linter \emptyset | \emptyset \rinter \\
		Interrupted
	 \circblockclose \\
	\quad \lpar \emptyset | \lchanset set\_interrupted, get\_interrupted \rchanset | \emptyset \rpar \\
	InterruptedController
     \circblockclose
\end{circusaction}
%
\begin{circusaction}
Interrupt \circdef \\
\quad interrupt~.~thread \then \\
\quad set\_interrupted~.~thread~!~True \then \\
\quad \Skip
\end{circusaction}
%
\begin{circusaction}
IsInterrupted \circdef \\
\quad isInterruptedCall~.~thread \then \\
\quad get\_interrupted~.~thread~?~interrupted \then \\
\quad isInterruptedRet~.~thread~!~interrupted \then \\
\quad \Skip
\end{circusaction}
%
\begin{circusaction}
Interrupted \circdef \\
\quad interruptedCall~.~thread \then \\
\quad get\_interrupted~.~thread~?~interrupted \then \\
\quad interruptedRet~.~thread~!~interrupted \then \\
\quad set\_interrupted~.~thread~!~False \then \\
\quad \Skip
\end{circusaction}
%
\begin{circusaction}
InterruptedController \circdef \\
\quad  \circblockopen
		get\_interrupted~.~thread~!~interrupted \then \\
		InterruptedController
	 \circblockclose \\
\quad \extchoice \\
\quad  \circblockopen
		set\_interrupted~.~thread~?~newInterrupted \then \\
		interrupted := newInterrupted \circseq \\
		InterruptedController
	 \circblockclose
\end{circusaction}
%
\begin{circusaction}
GetPriorityLevel \circdef \\
\quad 	get\_priorityLevel~.~thread~?~object~!~activePriority \then \\
\quad 	GetPriorityLevel
\end{circusaction}
%
\begin{circusaction}
\circspot  \circblockopen \lschexpract Init \rschexpract \circseq Execute \circblockclose \circinterrupt  \circblockopen done\_toplevel\_sequencer \then \Skip \circblockclose
\end{circusaction}
%
\begin{circus}
  \circend
\end{circus}
