channel a
Loop = a-> Loop

-- MANAGED THREAD

--MT Types
datatype SchedulableID = nullSchedulableId|schedulableA|schedulableB  
datatype MissionID = nullMissionId|missionA|missionB
datatype ExceptionType = interruptedException | illegalMonitorStateException | illegalArgumentException | illegalThreadStateException | illegalStateException | ceilingViolationException
nametype Bit = {0,1}
datatype ObjectID = objectA | objectB


-- MT CHannels


channel runCall : SchedulableID 
channel runRet : SchedulableID
channel initializeApplicationCall 
channel initializeApplicationRet 
channel done_schedulable : SchedulableID
channel activate_schedulables : MissionID
channel start_toplevel_sequencer : SchedulableID 
channel register : SchedulableID.MissionID
channel checkSchedulable : MissionID.Bool 
channel getSequencerCall 
channel getSequencerRet : SchedulableID
channel deregister : Set(SchedulableID) 
channel signalTerminationCall : SchedulableID 
channel signalTerminationRet : SchedulableID
channel cleanupSchedulableCall : SchedulableID
channel cleanupSchedulableRet : SchedulableID
channel done_toplevel_sequencer

channel get_controllingMission: SchedulableID.MissionID
channel set_controllingMission: SchedulableID.MissionID
channel get_applicationTerminating: SchedulableID.Bool
channel set_applicationTerminating: SchedulableID.Bool
channel end_managedThreadState : SchedulableID

nametype MTStateSync = {|get_controllingMission, set_controllingMission, get_applicationTerminating, set_applicationTerminating, end_managedThreadState |}
 
--Managed Thread

--\begin{zsection}
-- \SECTION  ManagedThread  \parents  ManagedThreadChan, SchedulableId, MissionId, MissionIds, TopLevelMissionSequencerChan,
--  SchedulableChan, SafeletMethChan, FrameworkChan
--\end{zsection}



ManagedThreadFW(schedulable) = 

	ManagedThreadFWState(schedulable, nullMissionId, False)
		[| MTStateSync |]
	ManagedThreadFWBehaviour(schedulable)


ManagedThreadFWState(schedulable, controllingMission, applicationTerminating) =
	(
		get_controllingMission.schedulable!controllingMission ->
		ManagedThreadFWState(schedulable, controllingMission, applicationTerminating)
	)
	[]
	(
		set_controllingMission.schedulable?newControllingMission ->
		ManagedThreadFWState(schedulable, newControllingMission, applicationTerminating)
	)
	[]
	(
		get_applicationTerminating.schedulable!applicationTerminating ->
		ManagedThreadFWState(schedulable, controllingMission, applicationTerminating)
	)
	[]
	(
		set_applicationTerminating.schedulable?newApplicationTerminating ->
		ManagedThreadFWState(schedulable, controllingMission, newApplicationTerminating)
	)
	[]
	(
		end_managedThreadState.schedulable -> 
		SKIP 
	)


ManagedThreadFWBehaviour(schedulable) =
    Start(schedulable) ; 
	get_applicationTerminating.schedulable?applicationTerminating ->
  	(
		if applicationTerminating == False then 
			(Execute(schedulable) ; Cleanup(schedulable) ; ManagedThreadFWBehaviour(schedulable) ) 
  		else 
		(
			end_managedThreadState.schedulable -> 
  			SKIP
   		) 
   )


Start(schedulable) =
  (
   Register(schedulable) ; 
   Activate(schedulable)
  )  
  []
  (
  	activate_schedulables?someMissionID -> 
  	Start(schedulable)
  ) 
  [] 
  (
	done_toplevel_sequencer -> 
	set_applicationTerminating.schedulable!True ->
	SKIP 
  )



Register(schedulable) =
  register.schedulable?mID ->
  checkSchedulable.mID?result ->
  set_controllingMission.schedulable!mID ->
  SKIP


Activate(schedulable) =
  get_controllingMission.schedulable?controllingMission ->	
  activate_schedulables.controllingMission ->  
  SKIP

Execute(schedulable)  = 
	 Run(schedulable)
		  [| {| runRet |} |]
	 Methods(schedulable)


Run(schedulable) =
  runCall.schedulable ->
  runRet.schedulable -> 
  done_schedulable.schedulable ->
  SKIP


  Methods(schedulable) = 
  	(
		SignalTerminationMeth(schedulable) ; 
		Methods(schedulable)
	)
	[]
	(
		runRet.schedulable -> 
		SKIP  
    )


  SignalTerminationMeth(schedulable) = 
   signalTerminationCall.schedulable -> 
   signalTerminationRet.schedulable -> SKIP
 

Cleanup(schedulable) = 
   cleanupSchedulableCall.schedulable ->
   cleanupSchedulableRet.schedulable -> SKIP



 
assert ManagedThreadFW(schedulableA); Loop :[ deadlock free [FD] ]
assert ManagedThreadFW(schedulableA) :[ divergence free ]
assert ManagedThreadFW(schedulableA) :[ deterministic  [FD] ]  
  
