channel a
Loop = a-> Loop

--MissionFW

--Mission Types
datatype SchedulableID = nullSequencerId|sequencerA|sequencerB 
datatype MissionID = nullMissionId|missionA|missionB
datatype ExceptionType = interruptedException | illegalMonitorStateException | illegalArgumentException | illegalThreadStateException | illegalStateException | ceilingViolationException
nametype Bit = {0,1}
datatype ObjectID = objectA | objectB

--Mission Channels

channel set_controllingSequencer : MissionID.SchedulableID
channel set_applicationTerminating : MissionID.Bool 
channel get_applicationTerminating : MissionID.Bool 
channel set_missionTerminating : MissionID.Bool 
channel set_activeSchedulables: MissionID.Set(SchedulableID) 
channel get_activeSchedulables: MissionID.Set(SchedulableID) 
channel add_schedulable: MissionID.SchedulableID
channel remove_activeSchedulables : MissionID.SchedulableID
channel get_missionTerminating : MissionID.Bool
channel get_registeredSchedulables : MissionID.Set(SchedulableID)

nametype MissionFWStateChan = 
	{|set_controllingSequencer, set_applicationTerminating, get_applicationTerminating, set_missionTerminating, set_activeSchedulables, get_activeSchedulables, add_schedulable, remove_activeSchedulables, get_missionTerminating, get_registeredSchedulables |}

channel start_mission : MissionID.SchedulableID
channel done_toplevel_sequencer
channel initializeCall : MissionID
channel initializeRet : MissionID
channel register : SchedulableID.MissionID
channel deregister : Set(SchedulableID)
channel checkSchedulable : MissionID.Bool
channel throw : ExceptionType
channel setCeilingPriority : MissionID.ObjectID.Bit
channel done_schedulables : MissionID
channel activate_schedulables : MissionID
channel stop_schedulables : MissionID
channel schedulables_stopped : MissionID
channel signalTerminationCall : SchedulableID 
channel signalTerminationRet : SchedulableID
channel done_schedulable : SchedulableID
channel schedulables_terminated : MissionID
channel end_mission_terminations : MissionID
channel requestTermination : MissionID.SchedulableID
channel terminationPendingCall : MissionID
channel terminationPendingRet : MissionID.Bool
channel cleanupSchedulableCall : SchedulableID
channel cleanupSchedulableRet : SchedulableID
channel cleanupMissionCall : MissionID 
channel cleanupMissionRet : MissionID.Bool
channel end_mission_app : MissionID
channel done_mission : MissionID.Bool

nametype TerminateSync = 
	{| schedulables_terminated, schedulables_stopped |}


MissionFW(mission) = 
	MissionFWState(mission, {}, {}, False, False, nullSequencerId)
	[|MissionFWStateChan|]
	MissionFWBehaviour(mission)


MissionFWState(mission, registeredSchedulables, activeSchedulables, missionTerminating, applicationTerminating, controllingSequencer) =
	(
		set_controllingSequencer.mission?mySequencer ->
		MissionFWState(mission, registeredSchedulables, activeSchedulables, missionTerminating, applicationTerminating, mySequencer)
	)
	[]
	(
		set_applicationTerminating.mission?newApplicationTerminating ->
		MissionFWState(mission, registeredSchedulables, activeSchedulables, missionTerminating, newApplicationTerminating, controllingSequencer)
	)
	[]
	(
		get_applicationTerminating.mission!applicationTerminating ->
		MissionFWState(mission, registeredSchedulables, activeSchedulables, missionTerminating, applicationTerminating, controllingSequencer)
	)
	[]
	(
		set_missionTerminating.mission?newMissionTerminating ->
		MissionFWState(mission, registeredSchedulables, activeSchedulables, newMissionTerminating, applicationTerminating, controllingSequencer)
	)
	[]
	(
		set_activeSchedulables.mission?newActiveSchedulables ->
		MissionFWState(mission, registeredSchedulables, newActiveSchedulables, missionTerminating, applicationTerminating, controllingSequencer)
	)
	[]
	(
		get_activeSchedulables.mission!activeSchedulables ->
		MissionFWState(mission, registeredSchedulables, activeSchedulables, missionTerminating, applicationTerminating, controllingSequencer)
	)
	[]
	(
		add_schedulable.mission?newSchedulable ->
		MissionFWState(mission, union(registeredSchedulables, {newSchedulable}), activeSchedulables, missionTerminating, applicationTerminating, controllingSequencer)
	)
	[]
	(
		get_registeredSchedulables.mission!registeredSchedulables ->
		MissionFWState(mission, registeredSchedulables, activeSchedulables, missionTerminating, applicationTerminating, controllingSequencer)
	)
	[]
	(
		remove_activeSchedulables.mission?schedulable ->
		MissionFWState(mission, registeredSchedulables, diff(activeSchedulables, {schedulable}), missionTerminating, applicationTerminating, controllingSequencer)
	)
	[]
	(
		get_missionTerminating.mission!missionTerminating ->
		MissionFWState(mission, registeredSchedulables, activeSchedulables, missionTerminating, applicationTerminating, controllingSequencer)
	)

MissionFWBehaviour(mission) =
	(  Start(mission) ;
		(
			get_applicationTerminating.mission?applicationTerminating ->
			if applicationTerminating == False then 
				(InitializePhase(mission) ; MissionPhase(mission) ; CleanupPhase(mission) ; MissionFWBehaviour(mission))
			else 
				 SKIP
			)
	)

Start(mission) =
  (
  	start_mission.mission?mySequencer ->
    set_controllingSequencer.mission!mySequencer ->
    SKIP
  ) 
  []
  (
  	done_toplevel_sequencer ->
  	set_applicationTerminating.mission!True ->
  	SKIP
  )

InitializePhase(mission) =
	initializeCall.mission ->
	(
		(	
			Register(mission) ;
			InitializePhase(mission)
		) 
		[]
		(
			SetCeilingPriority(mission) ;
			InitializePhase(mission)
		) 
		[]
		(
			initializeRet.mission ->
			SKIP
		) 
	)	

Register(mission) =
register?s!mission ->
(
	(
		checkSchedulable.mission?check:({True}) ->
		add_schedulable.mission!s ->
		SKIP
	)
	[]
	(
		checkSchedulable.mission?check:({False}) ->
		throw.illegalStateException ->
  		CHAOS(Events)
  	)
  )

RegisterException(mission) =
  register?s!mission ->
  throw.illegalStateException ->
  CHAOS(Events)  

SetCeilingPriority(mission) =
 setCeilingPriority.mission?o?p -> 
 SKIP

SetCeilingPriorityException(mission) =
 setCeilingPriority.mission?o?p -> 
 throw.illegalStateException ->
 CHAOS(Events)

Execute(mission) =
 ( 
 	get_registeredSchedulables.mission?registeredSchedulables ->
	if registeredSchedulables == {} then 
	(
		done_schedulables.mission ->
		SKIP
	)
	else 
	( 
	   activate_schedulables.mission ->
	   set_activeSchedulables.mission!registeredSchedulables ->
	   (
  	  	TerminateAndDone(mission) 
  	  		[| {| stop_schedulables, done_schedulables |} |]          
  	  	Methods(mission)
  	   ) 
  	)
	
  ) \  {|done_schedulables|}

TerminateAndDone(mission) =
 (
    (
		SignalTermination(mission)              
			[| TerminateSync |] 
		DoneSchedulables(mission)       
	);
	done_schedulables.mission ->
	SKIP
)
 
SignalTermination(mission) =
 (
  stop_schedulables.mission ->
  get_activeSchedulables.mission?schedulablesToStop ->
  StopSchedulables(schedulablesToStop) ;
  schedulables_stopped.mission ->
  SKIP
)
/\ (schedulables_terminated.mission -> SKIP)

StopSchedulables(schedulablesToStop) =
  	(|||  s :  schedulablesToStop @
  				signalTerminationCall.s ->
				signalTerminationRet.s ->
				SKIP)

DoneSchedulables(mission) =
   (
   	schedulables_stopped.mission -> 
   	SKIP
   )
   []
  -- (get_activeSchedulables.mission?activeSchedulables ->
--	DoneSchedulables(mission)
  -- )
  -- []
	(
		get_activeSchedulables.mission?activeSchedulables ->  
		(
		(
			[] schedulable : activeSchedulables @
				done_schedulable.schedulable ->  
				remove_activeSchedulables.mission!schedulable ->
				SKIP
		);  
		
		if activeSchedulables == {} then		
		(
			schedulables_terminated.mission ->
			SKIP
		)
		else 
		  DoneSchedulables(mission)
		)
	)

Methods(mission) =
 (
      	( 
      		(
      			RequestTerminationMeth(mission)
      				[|  {|end_mission_terminations|} |] 
      			TerminationPendingMeth(mission)
      		)       	
      	)
      	  [| {|end_mission_terminations|} |] 
      	(
      		done_schedulables.mission ->
      		end_mission_terminations.mission ->
      		SKIP
      	) 
    )

RequestTerminationMeth(mission) =
	(
		end_mission_terminations.mission -> 
		SKIP
	)
	[]
	(
		get_registeredSchedulables.mission?registeredSchedulables ->
	  (
	   	[] schedulable: registeredSchedulables @
	   	requestTermination.mission.schedulable ->
	   	SKIP
	  ) ;
	  (
	  	(
	  		get_missionTerminating.mission?missionTerminating:({False}) ->
	  		set_missionTerminating.mission!True ->
	  		stop_schedulables.mission ->
	  		RequestTerminationMeth(mission)
	  	)
	  	[]
	  	(
	  		get_missionTerminating.mission?missionTerminating:({True}) ->
	  		RequestTerminationMeth(mission)
	  	)
	  ) 
	)

TerminationPendingMeth(mission) =
   (
	end_mission_terminations.mission ->
	SKIP
   )
  []
  (
	terminationPendingCall.mission ->
	get_missionTerminating.mission?missionTerminating ->
	terminationPendingRet.mission!missionTerminating ->
	TerminationPendingMeth(mission)
   )

Cleanup(mission) =
( 
	get_registeredSchedulables.mission?registeredSchedulables ->
	deregister!registeredSchedulables ->
    CleanupSchedulables(mission) ;
     
    cleanupMissionCall.mission ->
    cleanupMissionRet.mission?continueSequencer ->
    Finish(mission, continueSequencer)
)

CleanupSchedulables(mission) =
	get_registeredSchedulables.mission?registeredSchedulables ->
	||| s : registeredSchedulables @
                cleanupSchedulableCall.s ->
                cleanupSchedulableRet.s ->	
                SKIP

Finish(mission, continueSequencer) =
   end_mission_app.mission ->
   done_mission.mission!continueSequencer ->
   SKIP

Exceptions(mission) =
( 
	RegisterException(mission) 
 	|||
	SetCeilingPriorityException(mission) 
) 
[]
(
	done_schedulables.mission ->
	SKIP
)

MissionPhase(mission) =
Execute(mission)
	[|  {|done_schedulables|} |] 
Exceptions(mission)

CleanupPhase(mission) =
Cleanup(mission)
	[|  {|done_schedulables|} |] 
Exceptions(mission)


assert MissionFW(missionA); Loop :[ deadlock free [FD] ]
assert MissionFW(missionA) :[ divergence free ]
assert MissionFW(missionA) :[ deterministic  [FD] ]
